<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Paulino Bermudez | HC3.0 - Docker Container</title>
        <!-- Favicon-->
        <link rel="icon" type="image/x-icon" href="../../styles/assets/favicon.ico" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v6.1.0/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="../../styles/css/styles.css" rel="stylesheet" />
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg bg-secondary text-uppercase fixed-top" id="mainNav">
            <div class="container">
                <a class="navbar-brand" href="#page-top">Up</a>
                <button class="navbar-toggler text-uppercase font-weight-bold bg-primary text-white rounded" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    Menu
                    <i class="fas fa-bars"></i>
                </button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ms-auto">
                        <li class="nav-item mx-0 mx-lg-1"><a class="nav-link py-3 px-0 px-lg-3 rounded" href="../../main.html">Home</a></li>
                        <li class="nav-item mx-0 mx-lg-1"><a class="nav-link py-3 px-0 px-lg-3 rounded" href="#contenidos">Content</a></li>
                        <li class="nav-item mx-0 mx-lg-1"><a class="nav-link py-3 px-0 px-lg-3 rounded" href="#contact">Contact</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- Masthead-->
        <header class="masthead bg-primary text-white text-center">
            <div class="container d-flex align-items-center flex-column">
                <!-- Masthead Heading-->
                <h1 class="masthead-heading text-uppercase mb-0">Docker.</h1>
                <!-- Masthead Subheading-->
                <p class="masthead-subheading font-weight-light mb-0"></p>
            </div>
        </header>
        <!-- Contents Section-->
        <section class="page-section portfolio" id="contenidos">
            <div class="container">
                <!-- Section Heading-->
                <h2 class="page-section-heading text-center text-uppercase text-secondary mb-0">Contents</h2>
                <!-- Icon Divider-->
                <div class="divider-custom">
                    <div class="divider-custom-line"></div>
                    <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                    <div class="divider-custom-line"></div>                
                </div>
                <!-- Contenidos de Kubernetes de EdX course -->
                <div class="divider-custom">
                    <p class="page-section">
                        <div>
                            <h1>Â¿What is Docker?</h1>                            
                            <p>
                                Docker is a platform that allows you to createm test and deploy applications quickly  and efficiently. It utilizes containerization technology to package an application and all its dependencies into a standardized unit called a container. 
                                These containers are isolated and lightweigth, ensuring consistency across various environments, making it easier to deploy and run application seamlessly on different systems. <br>
                                Docker is a game-changer in the world of software development and deployment. By utilizing multiple threads of processing, it can effectively manage and destribute containers accross different systems, optimizing resource utilization and enhancing overall performance. Moreover, Docker's support
                                for orchestration tools like Kubernetes enables seamless scaling and management of containers in large-scale production environments. This distributed approach ensures high availability and fault tolerance, making it an ideal choice for modern, containerized applications.
                            </p>
                            <hr>
                            <h1>Contents</h1>
                            <p>
                                <strong><i>Getting Started with Docker</i></strong>
                                <p>
                                    <ul>
                                        <li>
                                            Installing Docker on various operating systems                                
                                        </li>
                                        <li>
                                            Basic Docker CLI commands and usage                                
                                        </li>
                                    </ul>
                                </p>
                                <strong><i>Building Docker Images</i></strong>
                                <p>
                                    <ul>
                                        <li>
                                            Creating Docker images from Dockerfiles                                
                                        </li>
                                        <li>
                                            Best practices for building efficient and secure images                                
                                        </li>
                                    </ul>
                                </p>
                                <strong><i>Docker Networking</i></strong>
                                <p>
                                    <ul>
                                        <li>
                                            Configuring networking for containers                                
                                        </li>
                                        <li>
                                            Creating multi-container applications with Docker Compose                                
                                        </li>
                                    </ul>
                                </p>
                                <strong><i>Data Management with Docker Volumes</i></strong>
                                <p>
                                    <ul>
                                        <li>
                                            Persistent data storage in Docker containers                                
                                        </li>
                                        <li>
                                            Managing data volumes and backups                                
                                        </li>
                                    </ul>
                                </p>
                                <strong><i>Docker Hub and Container Registries</i></strong>
                                <p>
                                    <ul>
                                        <li>
                                            Leveraging Docker Hub for pre-built images                                
                                        </li>
                                        <li>
                                            Setting up private container registries                                
                                        </li>
                                    </ul>
                                </p>
                                <strong><i>Docker Compose and Orchestration</i></strong>
                                <p>
                                    <ul>
                                        <li>
                                            Simplifying multi-container application deployment                                
                                        </li>
                                        <li>
                                            Introduction to Docker Swarm for container orchestration                                
                                        </li>
                                    </ul>
                                </p>
                                <strong><i>Docker Security Best Practices</i></strong>
                                <p>
                                    <ul>
                                        <li>
                                            Securing Docker containers and images                                
                                        </li>
                                        <li>
                                            Implementing user authentication and role-based access                                
                                        </li>
                                    </ul>
                                </p>                                
                                <strong><i>Continuous Integration and Deployment with Docker</i></strong>
                                <p>
                                    <ul>
                                        <li>
                                            Integrating Docker into CI/CD pipelines                                
                                        </li>
                                        <li>
                                            Automating application deployment using Docker
                                        </li>
                                    </ul>
                                </p>
                                <strong><i>Build a containerized web application with Docker</i></strong>
                                <p>
                                    <ul>
                                        <li>
                                            Integrating Docker into CI/CD pipelines                                
                                        </li>
                                        <li>
                                            Automating application deployment using Docker
                                        </li>
                                    </ul>
                                </p>

                            </p>                                
                            <h2>How Docker works</h2>
                            <p>
                                Docker works by providing a standard way to run your code. Docker is an operating system for containers. Similar to how a virtual machine vitualizes (removes the need to directly manage) server hardware, containers virtualize the operating system of a server. Docker is installed on each server and provides 
                                simple commands you can use to build, start or stop containers. <br>
                                <img src="img/how-work.png" class="responsive" alt="">
                            </p>
                            <h2>Why use Docker</h2>
                            <p>
                                Using Docker lets you ship code faster, standardize application operations, seamlesslu move code and save money by improving resource utilization. With Docker, you get a single object that can reliably run anywhere. Docker's simple and straightforward syntax gives you full control. Wide adoption means there's a robust 
                                ecosystem of tools and off-the-shelf applications that are ready  to use with Docker.
                            </p>
                            <h2>When to use Docker</h2>
                            <p>
                                You can use Docker containers as a core building block creating modern applications and platforms. Docker makes it easy to build and run distributed microservices architectures, deploy your coude with standardized continuous integration and delivery pipelines, build highly-scalable data processing systems, and create fully-managed 
                                platforms for your developers. <br>
                                <div>
                                    <h5>MICROSERVICES</h5>
                                    <p>Build and scale distributed application architectures by taking advantage of standardized code deployments using Docker containers.</p>
                                </div>
                                <div>
                                    <h5>CONTINUOUS INTEGRATION & DELIVERY</h5>
                                    <p>Accelerate application delivery by standardizing environments and removing conflicts between language stacks and versions.</p>
                                </div>
                                <div>
                                    <h5>DATA PROCESSING</h5>
                                    <p>Provide big data processing as a service. Package data and analytics packages into portable containers that can be executed by non-technical users.</p>
                                </div>
                                <div>
                                    <h5>CONTAINERS AS A SERVICE</h5>
                                    <p>Build and ship distributed applications with content and infrastructure that is IT-managed and secured.</p>
                                </div>
                            </p>
                            <hr>
                            <h1>Install Docker Engine on SO</h1>
                            <p>                                
                                <h2>Installing Docker on Various Operating Systems:</h2>
                                <p>
                                    Docker provides straightforward installation procedures for different operating systems, making it accessible to developers across various platforms. Here's a brief overview of the installation steps for popular operating systems: <br>
                                    <div>
                                        1. <strong>Installing Docker on Linux:</strong> <br>
                                        - Docker is well-supported on most Linux distributions. You can typically install Docker using the package manager specific to your distribution. For example, on Ubuntu, you can use `apt` package manager, while on CentOS, you can use `yum` package manager. <br>
                                        Go <a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank" rel="noopener noreferrer">Docker Docs</a>. 
                                    </div>
                                    <div>
                                        2. <strong>Installing Docker on macOS:</strong> <br>
                                        - On macOS, you can install Docker Desktop, a user-friendly application that includes the Docker Engine, CLI, and a graphical interface. Simply download the Docker Desktop installer from the Docker website and follow the installation wizard. <br>
                                    </div>
                                    <div>
                                        3. <strong>Installing Docker on Windows:</strong> <br>
                                        - For Windows users, Docker Desktop is also available. Docker Desktop provides a seamless experience for running Docker on Windows. Download the installer from the Docker website and run the setup. <br>
                                        <div>
                                            <img src="img/dockerWindows.jpg" class="responsive" alt="">
                                        </div>
                                        <i>
                                            For Windows 10 Pro, Enterprise, or Education editions, you can use "Docker Desktop," which includes everything you need to run Docker containers. Download the installer from the Docker website and follow the on-screen instructions. <br>
                                            For Windows 10 Home or older versions, you can use "Docker Toolbox," an older version of Docker Desktop. Download the installer and follow the installation guide.
                                        </i>
                                    </div>
                                    After installing Docker, you'll have access to both the Docker Engine, responsible for managing containers, and the Docker CLI, which allows you to interact with Docker through the command line. <br>
                                    <a href="https://docs.docker.com/engine/install/" target="_blank" rel="noopener noreferrer">Docs Overview - Install Docker Engine</a>
                                    <div>
                                        <img src="img/docker-docs.png" class="responsive" alt="" srcset="">
                                    </div>
                                    <h1>Bash Script Installed Docker On Ubuntu</h1>
                                    <p>
<blockquote>    
    Script - Install Docker Engine.
        <code>
<pre>
    #!/bin/bash
    
    # Run the following command to uninstall all conflicting packages
    for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do sudo apt-get remove $pkg; done
    
    # Set up repository
    sudo apt-get update
    sudo apt-get install ca-certificates curl gnupg
    # Add Docker's official GPG key
    sudo install -m 0755 -d /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    sudo chmod a+r /etc/apt/keyrings/docker.gpg
    # set up the repository
    echo \
        "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
        "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" | \
        sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    
    # Install Docker Engine - Latest
    sudo apt-get update
    sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
</pre>    
    </code>
</blockquote>
                                    </p>
                                </p>
                                <h2>Basic Docker CLI Commands and Usage:</h2>
                                <p>
                                    Once Docker is installed, you can begin working with containers using the Docker CLI. Here are some fundamental commands to get you started:
                                <ul>
                                    <ol>
                                        1. <strong>`docker --version`:</strong> Check the installed Docker version.
                                    </ol>
                                    <ol>
                                        2. <strong>`docker info`:</strong> Display system-wide information about Docker.
                                    </ol>
                                    <ol>
                                        3. <strong>`docker pull &#8249; image-name &#8250;`:</strong> Download a Docker image from Docker Hub or another container registry.
                                    </ol>
                                    <ol>
                                        4. <strong>`docker images  [options] `:</strong> List all the Docker images available on your system.
                                    </ol>
                                    <ol>
                                        5. <strong>`docker run [options] &#8249; image-name &#8250;`:</strong> Run a container from a Docker image.
                                    </ol>
                                    <ol>
                                        6. <strong>`docker ps  [options] `:</strong> List all running containers.
                                    </ol>
                                    <ol>
                                        7. <strong>`docker ps -a`:</strong> List all containers, including those that are stopped.
                                    </ol>
                                    <ol>
                                        8. <strong>`docker stop &#8249; container-id &#8250;`:</strong> Stop a running container.
                                    </ol>
                                    <ol>
                                        9. <strong>`docker start &#8249; container-id &#8250;`:</strong> Start a stopped container.
                                    </ol>
                                    <ol>
                                        10. <strong>`docker restart &#8249; container-id &#8250;`:</strong> Restart a running container.
                                    </ol>
                                    <ol>
                                        11. <strong>`docker rm &#8249; container-id &#8250;`:</strong> Remove a stopped container.
                                    </ol>
                                    <ol>
                                        12. <strong>`docker rmi &#8249; image-name &#8250;`:</strong> Remove a Docker image from your system.
                                    </ol>
                                    <ol>
                                        13. <strong> docker exec [options]  &#8249; container-id/container_name &#8250;  &#8249; command &#8250;`:</strong> Runs a command iside a runnind container. <br>
                                        <i>Example:</i> 
                                        <code>
                                            docker exec -it my:container bash
                                        </code>
                                    </ol>
                                    <ol>
                                        14. <strong>docker build [options] -t &#8249; image_name &#8250; &#8249; path_to_dockerFile &#8250; </strong> Builds a Docker image from a Dockerfile. <br>
                                        <i>Example:</i>
                                        <code>
                                            docker build -t my_custom_image . 
                                        </code>
                                    </ol>
                                </ul>
                                These commands provide a glimpse of Docker's capabilities. As you explore Docker further, you'll learn about additional commands and features, such as creating custom Docker images using Dockerfiles, managing container networks, working with volumes for data persistence, and orchestrating multiple containers using Docker Compose or Kubernetes.
                                Now that you have Docker up and running and know some essential commands, you're ready to dive deeper into the world of containerization. 
                                </p>                                
                            </p>
                            <hr>
                            <h1>Understanding containerization and its advantages</h1>
                            <p>
                                Containerization is a revolutionary approach to application deployment and management, providing a lightweight and consistent environment for software to run in. Unlike traditional virtualization, where entire virtual machines are used to host applications, 
                                containerization enables us to package an application and all its dependencies into a single, self-sufficient unit known as a container. <br>
                                Containers isolate applications from the underlying infrastructure, ensuring that they run consistently across different environments, be it a developer's laptop, a testing server, or a production system. This portability eliminates the "it works on my 
                                machine" dilemma and streamlines the development workflow. Moreover, containerization minimizes conflicts between applications and maximizes resource utilization, 
                                making it an efficient solution for deploying multiple services on a single host.With containerization, applications become easily scalable, as additional containers can be spun up or down as demand fluctuates. This elasticity enables rapid response to 
                                changing workloads, leading to better resource management and cost-effectiveness. Additionally, containerization facilitates rapid application deployment, reducing the time between writing code and making it available to end-users. This accelerated development 
                                process gives businesses a competitive edge in today's fast-paced market.
                            </p>
                            <h1>Docker's role in modern Software Development.</h1>
                            <p>
                                At the forefront of the containerization revolution stands Docker, an open-source platform that has become synonymous with containers. Docker provides a user-friendly and robust ecosystem for creating, managing, and deploying containers effortlessly. <br>
                                By leveraging Docker, developers gain the ability to encapsulate their applications, along with all required libraries and dependencies, into a single Docker image. These images can then be shared, versioned, and reused, promoting collaboration among teams and simplifying the software distribution process. <br>
                                Moreover, Docker's architecture fosters a microservices-oriented approach to development, allowing applications to be broken down into smaller, modular components. This microservices architecture enhances maintainability, scalability, and fault isolation, enabling teams to work on different parts of an application independently.
                                Docker's impact extends beyond just the development phase. Its seamless integration with continuous integration and continuous deployment (CI/CD) pipelines streamlines the testing and release processes, ensuring a smooth and reliable delivery pipeline. <br>
                                In conclusion, Docker's containerization technology is a game-changer for modern software development. By enabling efficient container management, portability, scalability, and rapid deployment, Docker empowers developers and organizations to embrace agility, 
                                reliability, and innovation like never before. Whether you are a seasoned developer or just starting your journey, Docker is a must-have tool in your arsenal for building cutting-edge applications and services.
                            </p>
                            <hr>
                            <h1>Building Docker Images</h1>
                            <p>
                                MultiverseGPT: Building Docker images is a crucial aspect of using Docker effectively. Docker images are the building blocks of containers and define the environment and application setup that will be run within containers. Creating Docker images from Dockerfiles is a popular approach, 
                                as Dockerfiles provide a declarative way to specify the steps required to build the image. Here's a comprehensive guide to building Docker images and best practices for creating efficient and secure images:
                                <h2>Building Docker Images:</h2>

                                1. <strong>Create a Dockerfile:</strong> Start by creating a Dockerfile in your project directory. The Dockerfile contains a set of instructions for building the image. <br>
                                2. <strong>Choose a Base Image:</strong> Select an appropriate base image that suits your application's requirements. Official images from Docker Hub are recommended, as they are regularly maintained and generally more secure. <br>
                                3. <strong>Use Minimal Base Images:</strong> Opt for minimal base images like Alpine Linux when possible. These images are smaller, reducing the attack surface and improving image build times. <br>
                                4. <strong>Copy Application Files:</strong> Copy only necessary application files into the image. Use the `.dockerignore` file to exclude unnecessary files and directories. <br>
                                5. <strong>Run Commands Wisely:</strong> Order the commands in your Dockerfile wisely to leverage caching. Place frequently changing commands (e.g., copying source code) toward the end to maximize build cache reuse. <br>
                                6. <strong>Minimize Layers:</strong> Reduce the number of layers in the image. Each command in the Dockerfile creates a new layer. Combine related commands with `&&` to reduce the number of layers. <br>
                                7. <strong>Clean Up Unnecessary Files:</strong> Remove unnecessary temporary files and dependencies after installing packages to keep the image size small. <br>
                                8. <strong>Use Specific Tags:</strong> Always use specific tags for your base image, like a version number or commit hash. Avoid using "latest" as it can lead to unpredictability.                            
                                <h2>Creating Docker Images from Dockerfiles.</h2>
                                <p>                                
                                    1. <strong>Build the Image:</strong> Run the `<code>docker build</code>` command to build the Docker image using the Dockerfile in the current directory.
                                    <blockquote>
                                        <code>
                                            docker build -t image_name:tag .
                                        </code>
                                    </blockquote>                                
                                    2. <strong>Tagging Images:</strong> After building the image, tag it appropriately for easy identification and version control.
                                    <blockquote>
                                        <code>
                                            docker tag source_image:source_tag target_image:target_tag
                                        </code>
                                    </blockquote>                        
                                    3. <strong>Push to Registry (Optional):</strong> If you want to share your image with others or use it on multiple machines, push it to a container registry like Docker Hub.
                                    <blockquote>
                                        <code>
                                            docker push image_name:tag
                                        </code>
                                    </blockquote>                                
                                </p>
                                <h2>Best Practices for Building Efficient and Secure Images.</h2>
                                <p>
                                    By following these best practices, you can create efficient, secure, and reliable Docker images that provide a solid foundation for your containerized applications. <br>
                                    1. <strong>Keep Images Updated:</strong> Regularly update your base images and dependencies to incorporate the latest security patches and bug fixes. <br>
                                    2. <strong>Scan for Vulnerabilities:</strong> Utilize tools like Clair, Trivy, or Docker Security Scan to scan your images for vulnerabilities. <br>
                                    3. <strong>Use Official Images:</strong> Whenever possible, use official images from reputable sources, as they are well-maintained and frequently updated. <br>
                                    4. <strong>Avoid Unnecessary Privileges:</strong> Run containers with non-root users whenever possible to limit potential damage from container compromise. <br>
                                    5. <strong>Use Multi-Stage Builds:</strong> Use multi-stage builds to create smaller and more secure production images by discarding unnecessary build tools used during the build process. <br>
                                    6. <strong>Avoid Hardcoding Secrets:</strong> Never hardcode sensitive information like passwords or API keys directly into the image. Instead, use environment variables or Docker secrets. <br>
                                    7. <strong>Use .dockerignore:</strong> Properly configure `.dockerignore` to prevent adding unnecessary files to the image and to reduce its size. <br>
                                    8. <strong>Enable Content Trust:</strong> Enable Docker Content Trust to verify the authenticity and integrity of images pulled from Docker repositories. <br>
                                </p>
                            </p>
                            <h1>Docker networking: Configuring Networking for Containers</h1>
                            <p>
                                Docker provides various networking options to allow containers to communicate with each other and with external networks. By defaults, Docker sets up a bridge network for each container, providing them with internal IP address. Here are some key networking configurations for containers:
                                <ul>
                                    <li>Bridge Network. <br>
                                        This is the default network created by Docker. Containers within the same bridge network can communicate with each other using their internal IP addresses. Use the '--network' option to especify the bridge network when running containers.
                                    </li>
                                    <li>Host Network. <br>
                                        With the '--network=host' option, containers share the host's network stack. This means they can directly access services running in the host's networkm but it also expose the containers on the host's network interfaces.
                                    </li>
                                    <li>Overlay Network. <br>
                                        Overlay networks enable communication between containers accross multiple Docker hosts in a swarm cluster. This is essential for distributed applications and scaling. 
                                    </li>
                                    <li>Macvlan Network. <br>
                                        Macvlan allows containers to have unique MAC addresses, making them apeear as separate physical devices on the network. This is useful when containers need direct access to the physical network.
                                    </li>
                                    <li>User-Defined Bridge Network. <br>
                                        You can create custom  bridge networks using the '<code>docker network create</code>' commnad. This allows you to isolate containers on custom networks while enabling communication between them.
                                    </li>
                                    <li> Esternal Networking. <br>
                                        Containers can also use the host's network directly or connect to existing external networks, enabling interaction with other devices on the same network.
                                    </li>
                                </ul>
                                <h2>Creating Multi-Container Applications with Docker Compose</h2>
                                <p>
                                    Docker Compose simplifies the management of complex multi-container applicaions, making it easier to develop, deploy and scale them. With a well-defined 'docker-compose.yml' file, you can ensure consistency and reproducibility across different environments.
                                    <a href="https://docs.docker.com/compose/" target="_blank" rel="noopener noreferrer">Docker Compose</a> is a tool for defining and running multi-container Docker applications. It uses a YAML file (usually named 'docker-compose.yml') to define the services, networks and volumes requiref for your application. Here's how to create multi-container applications using Docker Compose:
                                    <ol>
                                        <li>
                                            <b>Install Docker Compose</b>Ensure you have Docker Compose installed on your system. If not you can download it from <a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener noreferrer">the Docker website.</a>
                                        </li>
                                        <li>
                                            <b>Write docker-compose.yml</b> Create a 'docker-compose.yml' file in your project directory. Define the services, networks and volumes needed for your application. Specify the images, environment variables, ports and other configurations for each service.
                                        </li>
                                        <li>
                                            <b>Build and Start</b> Run the following command to build and star your multi-container application. 
                                            <blockquote>
                                                <code>
                                                    docker-compose up
                                                </code>
                                            </blockquote>
                                        </li>
                                        <li>
                                            <b>Scaling Services</b> Docker Compose allows you to scale services easily. For instance, if you want to run multiple instances of a service, use the --scale' option.
                                            <blockquote>
                                                <code>
                                                    docker-compose up --scale service_name=num_instances
                                                </code>
                                            </blockquote>
                                        </li>
                                        <li>
                                            <b>Stop and Remove</b> To stop and remove the containers created by Docker Compose, use:
                                            <blockquote>
                                                <code>
                                                    docker-compose down
                                                </code>
                                            </blockquote>
                                        </li>
                                        <li>
                                            <b>Volumes</b> Define named volumes in your 'docker-compose.yml' to persist data across container restarts.
                                        </li>
                                        <li>
                                            <b>Networks</b> Specify custom networkds in the 'docker-compose.yml' file to control the communication netween containers.
                                        </li>
                                    </ol>
                                </p>                                
                            </p>
                            <h1>Data Management with Docker Volumes: Persistent Data Storage in Docker Containers</h1>
                            <p>
                                In docker, containers are ephemeral, meaning that the data inside them is nor persisted when the container is stopped or removed. However, Docker provides a feature called 'volumes' to handle persistent data storage. Docker volumes allow data to be stored outside the container, ensurinf that ir remains  available even after the container is fone or restarted. 
                                Here's how you can manage data volumes and achieve persistent data storage in DOcker containers.
                                <div>
                                    <h3>Creating Volumes.</h3>
                                    <p>
                                        You can create a Docker volume using the <code>docker volume create</code> command:
                                        <blockquote>
                                            <code>
                                                docker volume create volume_name
                                            </code>
                                        </blockquote>
                                        This will create a named volume that can be used by containers.
                                    </p>
                                    <h3>Mounting Volumes to Containers.</h3>
                                    <p>
                                        To make use of a colume in a container, you need to mount it when running the container. Use the '-v' or '--mount' flag to mount the volume.
                                        <blockquote>
                                            <code>
                                                docker run -d -v volume_name:/path/in/container image_name
                                            </code>
                                        </blockquote>
                                        or
                                        <blockquote>
                                            <code>
                                                docker run -d --mount source=volume_name, target=/path/in/container image_name
                                            </code>
                                        </blockquote>
                                        This mounts the named volume 'volume_name' to the especified path inside the container.
                                    </p>
                                    <h3>Using Bind Mounts.</h3>
                                    <p>
                                        Alternatively, you can use bind mounts to map a directory on the hosts to a path in the container.
                                        <blockquote>
                                            <code>
                                                docker run -d -v /host/path:/path/in/container image_name
                                            </code>
                                        </blockquote>
                                        This will persist data between the host and the container.
                                    </p>                                    
                                </div>  
                                <h2>Managing Data Volumes and Backups</h2>
                                <p>
                                    <h3>Inspecting Volumes</h3>
                                    <p>
                                        You can list all the volumes on your system using the command:
                                        <blockquote>
                                            <code>
                                                docker volume ls
                                            </code>
                                        </blockquote>
                                        To get detailed information ablout a specific volume, use:
                                        <blockquote>
                                            <code>
                                                docker volume inspect volume_name
                                            </code>
                                        </blockquote>
                                    </p>
                                    <h3>Backing up Volumes</h3>
                                    <p>
                                        Docker does not provide a built-in mechanism for backing up volumes, However, you can manually back up the data stored in the volume by copying it to a safe location on the hosts machine. <br>
                                        For named volumes, you can locate the data on the host by inspecting the volume (using <code>docker volume inspect volume_name</code> ) and findinf the "Mountpoint" property. Copy the data from that directory to a backup location. <br>
                                        For bind mounts, simply create backups of the directories on the host that are mounted into the containers.
                                    </p>
                                    <h3>Restoring Volumes</h3>
                                    <p>
                                        To restore a volume, copy the backed-up data back into the appropriate volume directory (for named volumes) or the bind-mounted directory on the host.
                                    </p>
                                    <h3>Removing Volumes</h3>
                                    <p>
                                        You can remove a volume using the <code>docker volume rm</code> command:
                                        <blockquote>
                                            <code>
                                                docker volume rm volume_name
                                            </code>
                                        </blockquote>
                                        Make sure to back up any important data before removing a volume, as the data will be permanently deleted. <br>
                                        By effectively using Docker volumes and managing backups, you can ensure that your containerized applications have access to persistent data and that important data is protected from accidental loss
                                    </p>
                                </p>

                            </p>
                            <h1>Docker Hub and Container Registries. Leveraging Docker Hub for Pre-build Images</h1>
                            <p>
                                <a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">Docker Hub is a cloud-based registry service provided by Docker</a>, where you can find a vast collection of pre-built Docker images for various software and services. Leveraging Docker Hub can save time and effort, as you can use existing images instad of building them from scratch. 
                                Here's how you can make the most of Docker Hub and its pre-build images.                                 
                                <div>
                                    <h2>Searching for images</h2>
                                    <img src="img/dockerhub.jpg" class="responsive" alt="">
                                    <p>
                                        You can search for Docker images on Docker Hub through the DOcker CLI or the Docker Hub website. Use the <code>docker search</code> command to find images related to specific applications or software. 
                                        <blockquote>
                                            <code>
                                                docker search image_name
                                            </code>
                                        </blockquote>
                                        The command will list all matching images available on Docker Hub, along with their description, start and other relevant information.
                                    </p>
                                    <h2>Pulling images.</h2>
                                    <p>
                                        To use a pre-built image from Docker Hub, you need to pull it to your local machine using the <code>docjer pull</code> command. 
                                        <blockquote>
                                            <code>
                                                docker pull image_name:tag
                                            </code>
                                        </blockquote>
                                        Replace 'image_name' eith the name of the image you want to use and 'tag' with the specific version or tag of the image (ex: <strong>latest</strong>).
                                        <div>
                                            <img src="img/docker-pull.jpg" class="responsive" alt="" srcset="">
                                        </div>
                                    </p>
                                    <h2>Running Containers with Pulled Images</h2>
                                    <p>
                                        Once you have pulled an image, you can use it to run containers on your local machine:
                                        <blockquote>
                                            <code>
                                                docker run -d image_name:tag
                                            </code>
                                        </blockquote>
                                        This will create and start a container using the specified image.
                                        <h3>Setting up Private Container Registries</h3>
                                        <p>
                                            Docker Hub is a public registry, which means anyone can access and download the images hosted there. However, in some cases, you may want to use private container registries to store and manage your own custom images 
                                            or sensitive applications. Docker provides the ability to set up private container registries using Docker's "Docker Distribution" (also known as Docker Registry).
                                            <h4>Using Docker Registry</h4>
                                            <p>
                                                Docker Registry is an open-source project that lets you host your private container registry. You can set up your registry on your server or cloud infrastructure, providing secure access and control over your images.
                                            </p>
                                            <h4>Running a Private Docker Registry</h4>
                                            <p>
                                                To run your private DOcker Registry, you can use the official Docker image available on Docker Hub.
                                                <blockquote>
                                                    <code>
                                                        docker run -d -p 5000:5000 --name registry registry:2
                                                    </code>
                                                </blockquote>
                                                This command starts a private registry on port 5000
                                            </p>
                                            <h4>Pushing Images to the Private Registry</h4>
                                            <p>
                                                Once the private registry is up and running, you can push your custom images to it:
                                                <blockquote>
                                                    <code>
                                                        docker tag local_image_name:tag your_registry_ip:5000/your_image_name:tag 
                                                        <br>
                                                        docker push your_registry_ip:5000/your_image_name:tag
                                                    </code>
                                                </blockquote>
                                                Replace your_registry_ip with the IP address or domain name of your private registry.
                                            </p>
                                            <h4>Pulling Images from the Private Registry</h4>
                                            <p>
                                                To pull images from your private registry on other machines, you need to log in first (if authentication is enabled) and then pull the image.
                                                <blockquote>
                                                    <code>
                                                        docker login your_registry_ip:5000
                                                        <br>
                                                        docker pull your_registry_ip:5000/your_image_name:tag
                                                    </code>
                                                </blockquote>
                                                Remember to handle authentication and security properly when setting up a private registry, especially when dealing with sensitive data and applications. <br>
                                                By using Docker Hub for pre-built images and setting up a private container registry for your custom images, you can enhance the efficiency, security, and flexibility of your Docker-based workflows.
                                            </p>
                                        </p>
                                    </p>
                                </div>
                            </p>
                            <h1>Docker Compose and Orchestration</h1>
                            <p>
                                Docker Compose is a powerful tool for defining and managing multi-container applications. It allows you to specify the services, networks, and volumes required for your application in a single YAML file <code>docker-compose.yml</code>. 
                                With Docker Compose, you can simplify the deployment of complex applications that consist of multiple interconnected containers. Here's how Docker Compose simplifies multi-container application deployment:
                                <ol>
                                    <li>
                                        <strong>Single Configuration File: </strong> <br>
                                        Docker Compose allows you to define all the services, their configurations, dependencies, and networks in one docker-compose.yml file. This single configuration file ensures consistency and simplifies the deployment process.
                                    </li>
                                    <li>
                                        <strong>Dependency Management: </strong> <br>
                                        You can specify dependencies between services, ensuring that dependent services start before the ones relying on them. This makes it easier to manage the order of container startup, especially in complex application setups.
                                    </li>
                                    <li>
                                        <strong>Easy Scalability: </strong> <br>
                                        Docker Compose makes it straightforward to scale individual services by defining the desired number of replicas for each service. This allows you to scale specific components of your application based on demand.
                                    </li>
                                    <li>
                                        <strong>Environment Variables and Secrets: </strong> <br>
                                        Docker Compose supports environment variables and Docker secrets, allowing you to manage sensitive information and configuration parameters without exposing them in the docker-compose.yml file.
                                    </li>
                                    <li>
                                        <strong>Simplified Commands: </strong> <br>
                                        Docker Compose provides simple commands to manage the entire application, such as starting all services, stopping them, or viewing the logs for all containers.
                                    </li>
                                    <li>
                                        <strong>Reproducibility and Portability: </strong> <br>
                                        With Docker Compose, you can recreate the same application setup in any environment that supports Docker Compose, ensuring reproducibility and portability.                                    
                                    </li>
                                </ol>
                                <h2>Simplifying multi-container application deployment.</h2>
                                <p>
                                    Simplifying multi-container application deployment is a key benefit of using containerization platforms like Docker. With Docker, you can package each component of your application into separate containers, ensuring consistency, portability, and ease of deployment. Here are some steps and best practices to simplify multi-container application deployment. <br>
                                    By following these best practices and leveraging Docker's containerization and orchestration features, you can significantly simplify the deployment of multi-container applications. This approach improves application reliability, enhances development workflows, and facilitates seamless scaling and management of your containerized applications.
                                    <h3>1. Containerization</h3>
                                    <p>
                                        First, containerize each component of your application using Docker. Identify the different services, databases, and other dependencies that make up your application, and create Docker images for each of them. This encapsulation ensures that each component runs consistently across different environments.
                                    </p>

                                    <h3>2. Use Docker Compose</h3>
                                    <p>
                                        Docker Compose is an essential tool for simplifying multi-container application deployment. Define your entire application stack, including services, networks, and volumes, in a single `<code>docker-compose.yml</code>` file. This allows you to manage all the services as a single unit and simplifies the deployment process.
                                    </p>

                                    <h3>3. Version Control</h3>
                                    <p>
                                        Keep your <code>docker-compose.yml</code> file and Dockerfiles under version control (e.g., Git). This ensures that changes to the application stack and configurations are tracked and can be rolled back if needed. Version control also enables collaboration among team members.
                                    </p>

                                    <h3>4. Automated Builds</h3>
                                    <p>
                                        Implement automated build pipelines to create Docker images from your application code and configurations. Tools like Docker Hub, GitHub Actions, or Jenkins can be used to automate the build process, ensuring that you always have the latest, tested, and optimized Docker images ready for deployment.
                                    </p>

                                    <h3>5. Dependency Management</h3>
                                    <p>
                                        Utilize Docker Compose's dependency management features to specify the relationships between different services. This ensures that dependent services start before the ones relying on them, simplifying the setup and reducing the risk of errors during deployment.
                                    </p>

                                    <h3>6. Environment Variables and Secrets</h3>
                                    <p>
                                        Leverage environment variables and Docker secrets in your `<code>docker-compose.yml</code>` file to manage sensitive information and configurations. This allows you to customize the behavior of your containers without exposing critical data in the YAML file.
                                    </p>

                                    <h3>7. Modular Architecture</h3>
                                    <p>
                                        Design your application with a modular architecture, where each component can run independently as a container. This approach allows you to scale, update, and manage individual components without affecting the rest of the application.
                                    </p>

                                    <h3>8. Configuration Management</h3>
                                    <p>
                                        Use container orchestration platforms like Docker Swarm or Kubernetes for more complex deployments. These tools provide advanced features for scaling, load balancing, service discovery, and rolling updates, making multi-container application deployment even more straightforward.
                                    </p>

                                    <h3>9. Continuous Integration/Continuous Deployment (CI/CD)</h3>
                                    <p>
                                        Integrate Docker deployment into your CI/CD pipeline to automate the process of building, testing, and deploying your application. This ensures that changes are automatically pushed to your environment, reducing the manual effort required for deployment.
                                    </p>                                    
                                </p>
                                <h2>Introduction to Docker Swarm for container orchestration</h2>
                                <p>
                                    <div>
                                        <img src="img/docker-swarm-arch.jpg" class="responsive" alt="">
                                    </div>
                                    Docker Swarm is Docker's built-in native container orchestration platform. It allows you to create and manage a cluster of Docker nodes (hosts) as a single virtual system, providing a straightforward way to deploy, scale, and manage containerized applications across multiple hosts. Docker Swarm simplifies the process of container orchestration and enables you to harness the full potential of containerization in a distributed environment. Here's an introduction to Docker Swarm and its key features:
                                    <h3>Key Concepts in Docker Swarm</h3>
                                    <p>
                                        <hr>
                                        1. <strong>Nodes</strong> Nodes are the instances that participate in the Docker Swarm cluster. Nodes can be physical machines or virtual machines that have Docker installed and are part of the swarm.
                                        <hr>
                                        2. <strong>Managers and Workers</strong> In a Docker Swarm cluster, there are two types of nodes: manager nodes and worker nodes. Manager nodes handle the orchestration and coordination tasks, while worker nodes execute the tasks and run the containers. There can be multiple manager nodes for high availability and fault tolerance.
                                        <hr>
                                        3. <strong>Services</strong> A service is a fundamental unit in Docker Swarm and represents the desired state of a containerized application. It defines the number of replicas, the container image, and network settings. Swarm ensures that the desired state is achieved and maintained, even if nodes fail or are added/removed.
                                        <hr>
                                        4. <strong>Stacks</strong> Stacks are used to deploy a collection of services, along with any associated networks and volumes. Stacks are defined in a Compose file (similar to Docker Compose), but they are deployed and managed by Swarm.
                                        <hr>
                                        5. <strong>Overlay Networking</strong> Swarm supports overlay networking, which allows containers on different nodes to communicate seamlessly without the need for additional configurations. This enables seamless communication across the entire swarm.
                                        <hr>
                                        6. <strong>Load Balancing</strong> Swarm provides built-in load balancing for services, distributing incoming traffic among the replicas of a service. This ensures that requests are efficiently processed across the swarm nodes.
                                    </p>    
                                    <h3>Key Features of Docker Swarm</h3>
                                    <p> 
                                        <hr>
                                        1. <strong>Scalability</strong> Docker Swarm makes it easy to scale services by specifying the desired number of replicas for each service. Swarm automatically distributes the containers across available worker nodes.
                                        <hr>
                                        2. <strong>High Availability</strong> Swarm provides high availability by ensuring that manager nodes are replicated and capable of handling leadership duties. If a manager node becomes unavailable, another manager takes over, preventing single points of failure.
                                        <hr>
                                        3. <strong>Rolling Updates</strong> Swarm allows you to perform rolling updates for services, meaning you can update services without any downtime by gradually replacing old containers with new ones.
                                        <hr>
                                        4. <strong>Security and Access Control</strong> Swarm supports various security mechanisms, including mutual TLS (Transport Layer Security) authentication between nodes, to secure communication within the cluster. You can also use access control lists (ACLs) to manage user access to the swarm.
                                        <hr>
                                        5. <strong>Integrated Storage</strong> Swarm supports volume plugins, enabling you to integrate external storage systems into the swarm cluster. This allows you to store data persistently outside the containers.
                                        <hr>
                                        6. <strong>Built-in Discovery and Service Discovery</strong> Swarm provides built-in service discovery, meaning you can refer to services by their names instead of specific IP addresses, making it easier to manage communication between services.
                                    </p>
                                    Overall, Docker Swarm offers a simple and powerful solution for container orchestration, especially for organizations already using Docker and looking for a built-in, easy-to-use solution for managing containers across a cluster of nodes. It provides the necessary tools to deploy, scale, and manage containerized applications efficiently while maintaining high availability and resilience. <br>
                                    <a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="noopener noreferrer">+info.</a>
                                </p>
                            </p>
                            <h1>Docker security best practices</h1>
                            <p>
                                Docker security is crucial to ensure the integrity and safety of your containerized applications and data. By following these best practices, you can minimize potential security risks and enhance the overall security posture of your Docker environment:
                                <div>
                                    1.<strong>Use Official Images</strong> Whenever possible, use official Docker images from reputable sources like Docker Hub. Official images are regularly maintained and scanned for security vulnerabilities. <br>
                                    2.<strong>Update Regularly</strong> Keep your Docker host and all images up to date. Regularly update the base images and application dependencies to include the latest security patches and bug fixes. <br>
                                    3.<strong>Avoid Unnecessary Privileges</strong> Run containers with non-root users whenever possible to limit the potential damage from container compromise. Avoid running containers with unnecessary privileges. <br>
                                    4.<strong>Limit Resources</strong> Use resource constraints like CPU and memory limits to prevent container abuse and resource exhaustion. <br>
                                    5.<strong>Employ Microservices Architecture</strong> Break your applications into smaller, isolated services, each running in its own container. This limits the potential impact of a security breach to a specific service. <br>
                                    6.<strong>Use Docker Content Trust</strong> Enable Docker Content Trust to verify the authenticity and integrity of images pulled from Docker repositories, preventing the use of tampered or malicious images. <br>
                                    7.<strong>Scan for Vulnerabilities</strong> Utilize vulnerability scanning tools like Trivy or Clair to scan Docker images for known security vulnerabilities before deployment. <br>
                                    8.<strong>Implement Network Segmentation</strong> Use Docker's networking features to segment containers based on functionality and security requirements. Limit container-to-container communication to only what is necessary. <br>
                                    9.<strong>Secure Docker Daemon Socket</strong> Protect the Docker daemon socket (usually at `/var/run/docker.sock`) and allow access only to authorized users or applications. Avoid running Docker with the default settings that allow unauthenticated access to the daemon. <br>
                                    10.<strong> Protect Sensitive Data</strong> Avoid hardcoding sensitive information (e.g., passwords, API keys) directly into the image. Use environment variables or Docker secrets to manage and protect sensitive data. <br>
                                    11.<strong> Secure Docker Compose Files</strong> Ensure that your Docker Compose files and other configuration files containing sensitive information are appropriately protected and not exposed to unauthorized users. <br>
                                    12.<strong> Monitor Container Activity</strong> Implement container monitoring and logging to detect suspicious or malicious behavior. Utilize tools like Docker logs, Sysdig, or other monitoring solutions to gain visibility into container activity. <br>
                                    13.<strong> Regular Audits and Reviews</strong> Conduct regular security audits and code reviews of Docker images, Dockerfiles, and other configuration files to identify and fix potential security issues. <br>
                                    14.<strong> Control Image Sources</strong> Control the sources of your Docker images, especially for images from external repositories. Avoid using images from unknown or untrusted sources. <br>
                                    15.<strong> Secure Image Build Process</strong> Ensure that your image build process is secure by using trusted base images and only adding necessary dependencies and packages. <br>
                                </div>
                                By implementing these best practices, you can strengthen the security of your Docker environment and protect your containerized applications from potential security threats and attacks. Remember that security is an ongoing process, and it's essential to stay informed about the latest security updates and best practices in the Docker ecosystem.
                            </p>
                            <h1>Continuous Integration and Deployment with Docker</h1>
                            <p>
                                Continuous Integration (CI) and Continuous Deployment (CD) with Docker is a powerful approach that streamlines the development, testing, and deployment of containerized applications. Docker's ability to create consistent environments through containerization, combined with CI/CD pipelines, enables teams to deliver software more efficiently and reliably. Here's how you can implement CI/CD with Docker:
                                <h2>Continuous Integration (CI)</h2>
                                <p>
                                    1. <strong>Version Control:</strong> Use a version control system (e.g., Git) to manage your application's source code and Docker-related files (e.g., Dockerfile, docker-compose.yml). <br>
                                    2. <strong>Automated Builds:</strong> Set up automated build pipelines that trigger whenever changes are pushed to the version control system. CI tools like Jenkins, GitLab CI, or GitHub Actions can be used for this purpose. <br>
                                    3. <strong>Building Docker Images:</strong> During the CI process, the CI tool should build the Docker images for your application. This involves executing the Docker build command and creating optimized, production-ready images. <br>
                                    4. <strong>Unit Testing:</strong> As part of the CI process, run automated unit tests within the containers to ensure that the application functions correctly in a containerized environment. <br>
                                    5. <strong>Image Scanning:</strong> Integrate Docker image scanning tools like Trivy or Clair to check for known security vulnerabilities in the built images. <br>
                                    6. <strong>Artifact Storage:</strong> Store the built Docker images in a registry, such as Docker Hub or a private container registry. These images will be used for deployment during the CD phase. 
                                </p>
                                <h2>Continuous Deployment (CD)</h2>
                                <p>
                                    1. <strong>Environment Setup:</strong> Provision and configure the target deployment environments (e.g., staging and production) using infrastructure-as-code tools like Terraform or Kubernetes. <br>
                                    2. <strong>Orchestration:</strong> Use container orchestration tools like Kubernetes or Docker Swarm for managing containerized applications across multiple nodes and environments. <br>
                                    3. <strong>CD Pipelines:</strong> Set up CD pipelines that automatically deploy the Docker images to the target environments based on predefined triggers, such as successful CI builds or specific Git branches/tags. <br>
                                    4. <strong>Rolling Updates:</strong> Implement rolling updates within the CD pipeline to minimize downtime during deployments. This involves deploying new versions of the application gradually, one at a time, and monitoring the health of the deployment. <br>
                                    5. <strong>Health Checks:</strong> Utilize health checks within the CD pipeline to ensure that the new containers are healthy and ready to receive traffic before routing traffic to them. <br>
                                    6. <strong>Rollback Mechanism:</strong> Implement an automated rollback mechanism in case the new version of the application experiences issues or failures.
                                </p>
                                <h2>Monitoring and Logging:</h2>
                                <p>
                                    1. <strong>Container Monitoring:</strong> Implement monitoring and logging for your Docker containers to gain visibility into their performance and health. Tools like Prometheus, Grafana, and Elasticsearch can be used for this purpose. <br>
                                    2. <strong>Application Performance Monitoring (APM):</strong> Utilize APM tools to monitor the performance and behavior of your application within the containers.
                                </p>
                                CI/CD with Docker allows for continuous integration of new features, automated testing, and efficient and reliable deployment of containerized applications. This approach enables development teams to deliver updates rapidly while maintaining the integrity and stability of the application throughout its lifecycle.
                            </p>
                            <hr>
                            <h1>Build a containerized web application with Docker</h1>
                            <p>
                                Package a web app so that it can be deployed as a Docker image and run from an Azure Container instance.
                                <h2>Learning objetives</h2>
                                <p>
                                    In this module, you wil:
                                    <ul>
                                        <li>Create a Dockerfile for a new container image based on a starter image from Docker Hub.</li>
                                        <li>Add files to an image using Dockerfile commands.</li>
                                        <li>Configure an image's startup commnad with Docker image.</li>
                                        <li>Build and run a web application packaged in a Docker image.</li>
                                        <li>Deploy a Docker image using the Azure Container Instance service.</li>
                                    </ul>
                                </p>
                                <h3>Prerequisites.</h3>
                                <p>
                                    <ul>
                                        <li>Familiarity with basic web application development concepts</li>
                                        <li>A Docker subscription</li>
                                        <li>Docker installed on your desktop computer.</li>
                                        <li>Git installed on your Desktop Computer.</li>
                                    </ul>
                                </p>
                                <h3>This module is part of these learning paths.</h3>
                                <p>
                                    Administer container in Azure and AWS. <br>
                                    Architect modern applications in Cloud <br>
                                    Deploy, manage and monitor Windows containers on Azure Kubernetes Service. 
                                </p>
                                <h2>Introduction</h2>
                                <p>
                                    Rapid deplotments is key to business agility. Modern organization must be able to release apps quickly to attract and retains business. Containerization saves time and reduce costs. You don't have to configure hardware and spend time installing operating systems and software to host a deployment. 
                                    Multiple apps can run in their isolated containers on the same hardware. It's possible to scale out quickly by starting more instances of containers. The images that run in containers are extensible, you can  start with a working base image and layer more functionality on top to create a new image. <br>
                                    Suppose you work for an online clothing retailer that's planning the development of a handful of internal apps, but it hasn't yet decided how to host them. You're looking for maximun compatibility, and  the apps may be hosted on-premises, in Azure, or another cloud provider. Some of the apps might share IaaS infrastructure. 
                                    In these cases, the company requires the apps to be isolated from each other. Apps can share the hardware resources, but an app shouldn't be able to interfere with the files, memory space, or other resources used by other apps. The company values the efficiency of its resources and wants somenthing with a compelling  app-development story. Docker seems an idean solution to these requirements.
                                    With Docke, you can quickly build and deploy an app and run it in its tailored enviroment, either locally or in te cloud. <br>
                                    In this module, you'll take an existing application and package it up as a Docker image. You'll automate the image-build process by defining the build steps in a Dockerfile. You'll test the app locally by using Docker for Windows. Finally, you'll upload the image to Azure Container Registry and run the application using the Azure Container Instance service. <br>
                                    By the end of this module, you'll be able to build Docker images and run them from Azure.
                                </p>
                                <h2>Retrieve an existing Docker image and deploy it locally</h2>
                                <p>
                                    Docker is a technology that enavles you to deploy applications and services quickly and easily. A Docker app runs using a Docker image. A Docker image is a prepackaged environment containing the application code and the environment in which the code executes. <br>
                                    In the corporate scenario described earlier, you want to investigate the deasibility of packaging and running an app with Docker. You decide to buil and deploy a Docker image running a test web app. <br>
                                    In this unit, you'll learn about the key concepts and processes involved in running a containerized app stored in a Docker image.
                                </p>
                                <h3>Overview of Docker</h3>
                                <p>
                                    Docker is a tool for running containerized apps. A containerized app includes the app and the filesystem that makes up the environment in which it sunrs. For example, a containerized app could consist od a database and other associated software and configuration information needed to run the app. <br>
                                    A containerized app typically has a much smaller footprint that a virtual machine configured to run the same app. This smaller footprint is because a virtual machine has to supply the entire operating sstem and associated supporting environment. A Docker container doesn't have this overhead because Docker uses the operating system kernel of the host computer to power the container. Downloading and starting a Docker image is daster and more space-efficient that downloading 
                                    and running a virtual machine that provides similar functionality. <br>
                                    You create a containerized apps by building an image that contains a set of files and a section of configuration information Docker uses. You run the app by asking Docker to start a container based on the image. When the container starts, Docker uses the image configuration to determine what application to run inside the container. Docker provides the operating system resources and the necessary security. It ensures that containers are running concurrently and remain relatively isolated. <br>
                                    <blockquote>
                                        <i>
                                            <strong>Important</strong> <br>

                                        </i>
                                    </blockquote>
                                </p>
                            </p>
                        </div>
                    </p>
                </div>
                <hr>
                <!-- Section Content-->
                <div class="row">

                </div>           
            </div>
        </section>
        <!-- Contact Section-->
        <section class="page-section" id="contact">
            <div class="container">
                <!-- Contact Section Heading-->
                <h2 class="page-section-heading text-center text-uppercase text-secondary mb-0">Contact Me</h2>
                <!-- Icon Divider-->
                <div class="divider-custom">
                    <div class="divider-custom-line"></div>
                    <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                    <div class="divider-custom-line"></div>
                </div>
            </div>
        </section>
        <!-- Footer-->
        <footer class="footer text-center">
            <div class="container">
                <div class="row">
                    <!-- Footer Location-->
                    <div class="col-lg-4 mb-5 mb-lg-0">
                        <h4 class="text-uppercase mb-4">Location</h4>
                        <p class="lead mb-0">
                            28801
                            <br />
                            Madrid, Spain
                        </p>
                    </div>
                    <!-- Footer Social Icons-->
                    <div class="col-lg-4 mb-5 mb-lg-0">
                        <h4 class="text-uppercase mb-4">Around the Web</h4>
                        <!-- 
                        <a class="btn btn-outline-light btn-social mx-1" href="#!"><i class="fab fa-fw fa-facebook-f"></i></a>
                        <a class="btn btn-outline-light btn-social mx-1" href="#!"><i class="fab fa-fw fa-twitter"></i></a>
                        -->
                        <a class="btn btn-outline-light btn-social mx-1" href="#!"><i class="fab fa-fw fa-linkedin-in"></i></a>
                        <a class="btn btn-outline-light btn-social mx-1" href="#!"><i class="fab fa-fw fa-github"></i></a>
                    </div>
                    <!-- Footer About Text-->
                    <div class="col-lg-4">
                        <h4 class="text-uppercase mb-4">About me</h4>
                        <p class="lead mb-0">
                            Aprendiendo de Sistemas.
                        </p>
                    </div>
                </div>
            </div>
        </footer>
         <!-- Copyright Section-->
         <div class="copyright py-4 text-center text-white">
            <div class="container"><small>
                <p style="text-align: center"> Copyright &copy; 2018-<script>document.write(new Date().getFullYear())</script> Pauchino09. </p>
            </small></div>
        </div>
        <!-- Portfolio Modals-->
        <!-- Portfolio Modal 1-->
        <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" aria-labelledby="portfolioModal1" aria-hidden="true">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header border-0"><button class="btn-close" type="button" data-bs-dismiss="modal" aria-label="Close"></button></div>
                    <div class="modal-body text-center pb-5">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Portfolio Modal - Title-->
                                    <!----------------------------------------------------------- KUBERNETES -------------------------------------------------------------------->
                                    <h2 class="portfolio-modal-title text-secondary text-uppercase mb-0">Docker & Kubernetes</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                        <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Portfolio Modal - Image-->
                                    <!-- <img class="img-fluid rounded mb-5" src="assets/img/portfolio/container.png" alt="..." /> -->
                                    <!-- Portfolio Modal - Text-->
                                    <!----------------------------------------------------------- Content -------------------------------------------------------------------->
                                    <p class="mb-4">
                                        <a href="deploy/kubernetes.html" rel="noopener noreferrer">Kubernetes</a>
                                    </p>
                                    <button class="btn btn-primary" data-bs-dismiss="modal">
                                        <i class="fas fa-xmark fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Portfolio Modal 2-->
        <div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" aria-labelledby="portfolioModal2" aria-hidden="true">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header border-0"><button class="btn-close" type="button" data-bs-dismiss="modal" aria-label="Close"></button></div>
                    <div class="modal-body text-center pb-5">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Portfolio Modal - Title-->
                                    <!----------------------------------------------------------- JENKINS -------------------------------------------------------------------->
                                    <h2 class="portfolio-modal-title text-secondary text-uppercase mb-0">Jenkins</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                        <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Portfolio Modal - Image-->
                                    <img class="img-fluid rounded mb-5" src="assets/img/portfolio/Jenkins.png" alt="..." />
                                    <!-- Portfolio Modal - Text-->
                                    <!----------------------------------------------------------- Content -------------------------------------------------------------------->
                                    <p class="mb-4">
                                        
                                    </p>
                                    <button class="btn btn-primary" data-bs-dismiss="modal">
                                        <i class="fas fa-xmark fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Portfolio Modal 3-->
        <div class="portfolio-modal modal fade" id="portfolioModal3" tabindex="-1" aria-labelledby="portfolioModal3" aria-hidden="true">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header border-0"><button class="btn-close" type="button" data-bs-dismiss="modal" aria-label="Close"></button></div>
                    <div class="modal-body text-center pb-5">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Portfolio Modal - Title-->
                                    <!----------------------------------------------------------- GITLAB -------------------------------------------------------------------->
                                    <h2 class="portfolio-modal-title text-secondary text-uppercase mb-0">Gitlab</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                        <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Portfolio Modal - Image-->
                                    <img class="img-fluid rounded mb-5" src="assets/img/portfolio/Git.png" alt="..." />
                                    <!-- Portfolio Modal - Text-->
                                    <!----------------------------------------------------------- Content -------------------------------------------------------------------->
                                    <p class="mb-4">
                                        
                                    </p>
                                    <button class="btn btn-primary" data-bs-dismiss="modal">
                                        <i class="fas fa-xmark fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Portfolio Modal 4-->
        <div class="portfolio-modal modal fade" id="portfolioModal4" tabindex="-1" aria-labelledby="portfolioModal4" aria-hidden="true">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header border-0"><button class="btn-close" type="button" data-bs-dismiss="modal" aria-label="Close"></button></div>
                    <div class="modal-body text-center pb-5">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Portfolio Modal - Title-->
                                    <!----------------------------------------------------------- JIRA OR ICINGA -------------------------------------------------------------------->
                                    <h2 class="portfolio-modal-title text-secondary text-uppercase mb-0">Jira (or Icinga).</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                        <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Portfolio Modal - Image-->
                                    <img class="img-fluid rounded mb-5" src="assets/img/portfolio/Jira.jpg" alt="..." />
                                    <!-- Portfolio Modal - Text-->
                                    <!----------------------------------------------------------- Content -------------------------------------------------------------------->
                                    <p class="mb-4">
                                        
                                    </p>
                                    <button class="btn btn-primary" data-bs-dismiss="modal">
                                        <i class="fas fa-xmark fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Portfolio Modal 5-->
        <div class="portfolio-modal modal fade" id="portfolioModal5" tabindex="-1" aria-labelledby="portfolioModal5" aria-hidden="true">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header border-0"><button class="btn-close" type="button" data-bs-dismiss="modal" aria-label="Close"></button></div>
                    <div class="modal-body text-center pb-5">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Portfolio Modal - Title-->
                                    <!----------------------------------------------------------- TERRAFORM -------------------------------------------------------------------->
                                    <h2 class="portfolio-modal-title text-secondary text-uppercase mb-0">Terraform.</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                        <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Portfolio Modal - Image-->
                                    <img class="img-fluid rounded mb-5" src="assets/img/portfolio/Terra.png" alt="..." />
                                    <!-- Portfolio Modal - Text-->
                                    <!----------------------------------------------------------- Content -------------------------------------------------------------------->
                                    <p class="mb-4">
                                        
                                    </p>
                                    <button class="btn btn-primary" data-bs-dismiss="modal">
                                        <i class="fas fa-xmark fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Portfolio Modal 6-->
        <div class="portfolio-modal modal fade" id="portfolioModal6" tabindex="-1" aria-labelledby="portfolioModal6" aria-hidden="true">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header border-0"><button class="btn-close" type="button" data-bs-dismiss="modal" aria-label="Close"></button></div>
                    <div class="modal-body text-center pb-5">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Portfolio Modal - Title-->
                                    <!----------------------------------------------------------- AWS -------------------------------------------------------------------->
                                    <h2 class="portfolio-modal-title text-secondary text-uppercase mb-0">AWS</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                        <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Portfolio Modal - Image-->
                                    <img class="img-fluid rounded mb-5" src="assets/img/portfolio/AWS.png" alt="..." />
                                    <!-- Portfolio Modal - Text-->
                                    <!----------------------------------------------------------- Content -------------------------------------------------------------------->
                                    <p class="mb-4">
                                        
                                    </p>
                                    <button class="btn btn-primary" data-bs-dismiss="modal">
                                        <i class="fas fa-xmark fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
        <!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *-->
        <!-- * *                               SB Forms JS                               * *-->
        <!-- * * Activate your form at https://startbootstrap.com/solution/contact-forms * *-->
        <!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *-->
        <script src="https://cdn.startbootstrap.com/sb-forms-latest.js"></script>
    </body>
</html>
